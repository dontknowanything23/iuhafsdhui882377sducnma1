<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">
<meta name="author" content="AuthorXY">
<link rel="stylesheet" type="text/css" href="Carnot_Style.css">
<title>CARNOT manual - 3 Advanced Topics</title>

<style type="text/css">body{margin-left:108.0pt;}</style>
</head>

<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">
<hr>
<h1><a name="advanced_topics"><b>3. Advanced Topics</b></a></h1>
<hr>

<p><a href="#3.1_Creating_your_own_C_S-functions">3.1 Creating your own S-functions</a></p>
<p><a href="#3.2_The_Carlib_Library">3.2 The Carlib Library</a></p>
<p><a href="#3.3_Rapid_Accelerator_Mode">3.3 Rapid Accelerator Mode</a></p>
<p><a href="#3.4_Further_acceleration_methods">3.4 Further acceleration methods</a></p>
<p><a href="#3.5_Messages_and_error_handling">3.5 Messages and error handling</a></p>
<p><a href="#3.6_Floating_point_accuracy">3.6 Floating point accuracy</a></p>
<p><a href="#3.7_Target_Language_Compiler_(TLC)">3.7 Target Language Compiler (TLC)</a></p>
<p><a href="#3.8_Version_Management">3.8 Version Management</a></p>
<p><a href="#3.9_Extending_the_CARNOT_library_in_SIMULINK_environment">3.9 Extending the CARNOT block Library in SIMULINK Environment</a> </p>
<p><a href="#3.10_Adding_functions_and_fluids_to_the_Carlib">3.10 Adding functions and fluids to the Carlib</a></p>
<hr>

<h2><a name="3.1_Creating_your_own_C_S-functions">3.1 Creating your own C S-functions</a></h2>
<p>Simulink offers an interface to C code. This has some advantages: </p>
<ul>
	<li>you can use legacy code</li>
	<li>you can use loops and if conditions more easily than in Simulink</li>
	<li>C code is much quicker than Simulink models in normal mode and quicker than 
	embedded Matlab code in normal and accelerator mode.</li>
	<li>there are more debugging possibilities</li>
</ul>
<p>Of course, there are some disadvantages as well: </p>
<ul>
	<li>the interface is very complicated</li>
	<li>you are forced to use pointers, which increases the risk of crashes</li>
</ul>
<p>Some basic rules for Carnot s-functions :</p>
<ul>
	<li><a href="../guidelines/Carnot_Filenames_and_Folders.txt">
	Carnot_Filenames_and_Folders</a></li>
	<li><a href="../guidelines/Carnot_S_functions.txt">Carnot_S_functions</a></li>
</ul>
<p><strong>Preparation</strong></p>
<p>In order to compile the C code, you need a compiler, e.g. MinGW or the Microsoft SDK 7.1. 
For the choice of a compiler which works well with your Matlab installation 
please consult <a href="https://www.mathworks.com/matlabcentral/fileexchange/52848-matlab-support-for-mingw-w64-c-c-compiler">
https://www.mathworks.com/matlabcentral/fileexchange/52848-matlab-support-for-mingw-w64-c-c-compiler</a>. </p>
<p>The compiler MinGW can be installed via the "Home" tab -> "Add-Ons" -> "Get Add-Ons".</p>
<hr>
<p>Remark: The mex files of the current version of Carnot have been compiled with MinGW-w64 6.3 .</p>
<p>Warning: The current mex-files have been compiled with MinGW. Please do not mix two compilers; this will cause unexpected results.
So if you want to use other compilers (or versions), please re-compile Carnot before running your simulations.</p>
<hr>
<p>After installation, enter <br>
<tt>mex -setup </tt><br>
at the Matlab prompt and choose the right compiler. Now Matlab and Simulink are ready to use C code. </p>
<p>Important differences between Matlab and C</p>
<ul>
	<li>In Matlab all indices start with 1, in C all indices start with 0.</li>
	<li>In C code S-functions it is possible to access two dimensional inputs. Please 
	consider that the first index in Matlab is the row and the second the column. 
	In C it is the other way around.</li>
	<li>In C code S-functions outputs and parameters are always one dimensional. 
	Even if a two dimensional matrix is passed through, it must be accessed as a 
	one dimensional array in C.</li>
	<li>Similarly all derivatives and continuous states (i.e. integrators) are one 
	dimensional in C.</li>
	<li>Simulink defines several variable types. For example, real_T is equivalent 
	to double if you run your code on an ordinary PC.</li>
</ul>
<br>
<p><strong>Example S-Function</strong></p>
<p>There are several S-function examples included in Simulink. Unfortunately, all 
these examples are not self-explanatory. In order to find a good starting point, 
consider the example S-function ExampleSFunction.c. Change to the directory of the 
example. Type <br>
<tt>mex ExampleSFunction.c</tt><br>
Please remember that Simulink is case 
sensitive. If you do not consider this, the code will be compiled, because Windows 
is not case sensitive. However, Simulink will crash if you run a model including 
the S-function in this case. After compiling a file ExampleSFunction.mexw64 
will appear in your directory. This file is actually a dynamic link library (DLL), 
which will be included by Simulink. <br><br>
Now you can open the the Simulink example model. In the upper part, the S-function 
is incorporated, in the lower part the same functionality with Simulink is implemented. </p>
<p>As you can see, there are two different outputs: </p>
<ol>
	<li>Two numbers (vector u0) are added and multiplied by another number (p0)</li>
	<li>Two numbers (vector u1) are added and multiplied by another number (p0). 
	Also the result of step 1 is added and everything is integrated.</li>
</ol>
<p>If you run the model, you can observe that the same numbers appear in the upper 
and the lower part. <br><br>Please double click on the S-function block. Here the 
S-function's parameters (here only one parameter &quot;1&quot;, which is p0) are 
defined. If you click on &quot;edit&quot; the source code<br>of the S-function will 
opened. The code is well documented, so that only a brief description is given here.
<br><br>In general, an S-function includes much information, which must be presented 
to Simulink. The simple example has more than 200 lines of code. All information 
is stored in a structure of type SimStruct. Do not access this structure directly. 
There are access functions defined by Simulink. <br></p>
<p>Every S-Function has to have the following functions: </p>
<ul>
	<li>mdlInitializeSizes</li>
	<li>mdlInitializeSampleTimes</li>
	<li>mdlOutputs</li>
	<li>mdlTerminate</li>
</ul>
<p>In our example you will find two other functions, mdlDerivatives, which is needed 
for integration and mdlInitializeConditions, which defines the initial values of 
the integrators.</p>
<p>When programming an C code S-function, you have to follow these steps:</p>
<ol>
	<li>Tell Simulink about the C code's interface to Simulink:<br>
	In the function mdlInitializeSizes Simulink is told about the interfaces.<br>
	Here are defined :
	<ul>
		<li>how many inports are used (in our example 2, u0 and u1)</li>
		<li>the size of each inport (in our example 2 for both inports)</li>
		<li>how many parameters are used (in our example 1, p0)</li>
		<li>how many outports are used (in our example 2, y0 and y1)</li>
		<li>the size of each outport (in our example 1 for each outport)</li>
		<li>the size of the integrator (in Simulink called continuous state) (in our example 1)</li>
		<li>the number and size of Work vectors (in our example 1 DWork vector of size 1)</li>
		<li>other information (advanced options as e.g. SimState compliance, ...)</li>
	</ul>
	For the direct feed through flag see the description of mdlOutputs.</li>
	<li>Tell Simulink about the sampling rate: <br>In the function mdlInitializeSampleTimes 
	Simulink gets information about the sample time. Normally, the sample time is 
	continuous or inherited.</li>
	<li>Set the outport: <br>The function mdlOutputs will write the outputs to Simulink.
	<br>In our example two different steps are done:
	<ol>
		<li>The outport 0 is the sum of the two elements of inport 0 multiplied 
		by the parameter 0.</li>
		<li>The outport 1 is the continuous state 0, which is the integration of 
		the derivative defined in mdlDerivative.</li>
	</ol>
	From the first step it can be derived that at least one outport (here outport 
	0) is directly depended on the input 0. In Simulink this behaviour is called 
	direct feed through. Consequently, the direct feed through flag for inport 0 
	has to be activated in mdlInitializeSizes.</li>
	<li>[optional] Calculate the derivatives with respect to time <br>In the function 
	mdlDerivatives the derivatives with respect to time are defined. The only derivative 
	defined is the sum of the two elements of inport 1 multiplied by the parameter 
	0.</li>
	<li>[optional] Set the initial conditions of the continuous states (integrators):
	<br>In the function mdlInitializeConditions the continuous state, which has 
	been registered in mdlInitializeSizes, is set. In our example the integration 
	constant is zero.<br>Furthermore, the initial values of the Work vectors can 
	be set here.</li>
	<li>Tell Simulink what to do when the simulation is finished: <br>The last function 
	is mdlTerminate. It is executed when the simulation stops. It can be used to 
	free allocated memory. In our example the function is empty.</li>
</ol>
<br>
<p><strong>Debug functions in C code</strong></p>
<p>Unfortunately, C is not a safe language. For example, it is possible to access 
non-existing elements of an array. If you do so, C will access the address in memory, 
where the element would be if existent. Probably there are other data or execution commands 
at this address, so that the program will return unexpected results or will crash.<br>
To prevent this, you can use the functions provided in debugfunction.c. These function 
check if an element exists, read from this element or write to this element. Since a 
check needs time, this should be done during development or debugging. Please refer 
to the file ExampleSFunctionDebug.c, which has the same function as ExampleSFunction.c, 
but usesed safe access functions as described below.<br>
In order to reduce the simulation effort with tested code, a pre-compiler directive 
can be used to switch on and off the checking. In line 107 in a kind of variable 
called DEBUGME is defined:<tt><br>
#define DEBUGME</tt>
<br>
This variable is checked later on, for example is line 120<tt><br>
#ifdef DEBUGME <br>
&nbsp;&nbsp;&nbsp;&nbsp; #include "debugfunctions.h"<br>
#endif</tt><br>
This means, that the code between #ifdef and #endif is compiled only, if the variable 
DEBUGME has been defined. So there is a simple way to exclude parts of a code.
You will find similar construction all over the C-file.<br><br>
All access function return a boolean_T. The result is true if the element is accessible and false if not.
</p>

<p>Functions to check if an element existis:</p>
<ul>
<li>boolean_T check_Inport(SimStruct *S, int_T port);</li>
<li>boolean_T check_InportElement(SimStruct *S, int_T port, int_T element);</li>
<li>boolean_T check_Outport(SimStruct *S, int_T port);</li>
<li>boolean_T check_OutportElement(SimStruct *S, int_T port, int_T element);</li>
<li>boolean_T check_ContState(SimStruct *S, int_T number);</li>
<li>boolean_T check_ContStateDerivative(SimStruct *S, int_T number);</li>
<li>boolean_T check_DiscState(SimStruct *S, int_T number);</li>
<li>boolean_T check_DWork(SimStruct *S, int_T number);</li>
<li>boolean_T check_DWorkElement(SimStruct *S, int_T number, int_T element);</li>
<li>boolean_T check_RWork(SimStruct *S, int_T number);</li>
<li>boolean_T check_IWork(SimStruct *S, int_T number);</li>
<li>boolean_T check_PWork(SimStruct *S, int_T number);</li>
<li>boolean_T check_Parameter(SimStruct *S, int_T number);</li>
<li>boolean_T check_ParameterElement(SimStruct *S, int_T number, int_T element);</li>
</ul>
<p>Functions to read an element:</p>
<ul>
<li>boolean_T read_InportElement(SimStruct *S, int_T port, int_T element, real_T *value);</li>
<li>boolean_T read_ContState(SimStruct *S, int_T element, real_T *value);</li>
<li>boolean_T read_ContStateDerivative(SimStruct *S, int_T element, real_T *value);</li>
<li>boolean_T read_DiscState(SimStruct *S, int_T element, real_T *value);</li>
<li>boolean_T read_DWorkElement(SimStruct *S, int_T number, int_T element, void *value);</li>
<li>boolean_T read_RWork(SimStruct *S, int_T number, real_T *value);</li>
<li>boolean_T read_IWork(SimStruct *S, int_T number, int_T *value);</li>
<li>boolean_T read_PWork(SimStruct *S, int_T number, void* ptr);</li>
<li>boolean_T read_ParameterElement(SimStruct *S, int_T number, int_T element, real_T *value);</li>
</ul>
<p>Functions to write an element:</p>
<ul>
<li>boolean_T write_OutportElement(SimStruct *S, int_T port, int_T element, real_T value);</li>
<li>boolean_T write_ContState(SimStruct *S, int_T element, real_T value);</li>
<li>boolean_T write_ContStateDerivative(SimStruct *S, int_T element, real_T value);</li>
<li>boolean_T write_DiscState(SimStruct *S, int_T element, real_T value);</li>
<li>boolean_T write_DWorkElement_real(SimStruct *S, int_T number, int_T element, real_T value);</li>
<li>boolean_T write_DWorkElement_real32(SimStruct *S, int_T number, int_T element, real32_T value);</li>
<li>boolean_T write_DWorkElement_int8(SimStruct *S, int_T number, int_T element, int8_T value);</li>
<li>boolean_T write_DWorkElement_int16(SimStruct *S, int_T number, int_T element, int16_T value);</li>
<li>boolean_T write_DWorkElement_int32(SimStruct *S, int_T number, int_T element, int32_T value);</li>
<li>boolean_T write_DWorkElement_uint8(SimStruct *S, int_T number, int_T element, uint8_T value);</li>
<li>boolean_T write_DWorkElement_uint16(SimStruct *S, int_T number, int_T element, uint16_T value);</li>
<li>boolean_T write_DWorkElement_uint32(SimStruct *S, int_T number, int_T element, uint32_T value);</li>
<li>boolean_T write_DWorkElement_boolean(SimStruct *S, int_T number, int_T element, boolean_T value);</li>
<li>boolean_T write_RWork(SimStruct *S, int_T number, real_T value);</li>
<li>boolean_T write_IWork(SimStruct *S, int_T number, int_T value);</li>
<li>boolean_T write_PWork(SimStruct *S, int_T number, void* ptr);</li>
</ul>
<br>
<p><b>Example1:</b><br>
To check if the inport 0, element 1 exists use <tt><br>
if (check_InportElement(S, 0, 1)) <br>
{ <br>
&nbsp;&nbsp;&nbsp;&nbsp; /* code */ <br>
} <br></tt>
</p>

<p><b>Example 2:</b><br>
To read inport 0, element 1 use <tt><br>
real_T value; <br>
if (!read_InportElement(S, 0, 1,&value)) <br>
{ <br>
&nbsp;&nbsp;&nbsp;&nbsp; printf("Error in line %i\n", __LINE__);
&nbsp;&nbsp;&nbsp;&nbsp; printf("Inport 0, element 1 not accessible!\n"); <br>
} <br></tt>
The variable __LINE__ will be defined by the compiler and return the line number in the source code. This will help you to find the error.
</p>

<p><b>Example 3:</b><br>
To write outport 0, element 1 use <tt><br>
real_T value; <br>
if (!writeOutportElement(S, 0, 1,value)) <br>
{ <br>
&nbsp;&nbsp;&nbsp;&nbsp; printf("Error in line %i\n", __LINE__);<br>
&nbsp;&nbsp;&nbsp;&nbsp; printf("Outport 0, element 1 not accessible!\n"); <br>
} </tt><br>
</p>

<p><strong>Incorporating Carlib in C code</strong></p>
<p>The C code library for S-functions is carlib.c (including the header file carlib.h). 
In this file several functions as fluid properties are supplied (see next chapter). 
Please use the file simplepipe.c and the corresponding model as an example. The 
C code is well documented by comments, so here only a brief introduction is given.
<br>In order to compile the S-function, the carlib library, carlib.c, has to be 
incorporated. First, you have to know where this library is located. Use the Carnot 
command <br>path_carnot('carlibsrc') <br>This may return e.g. c:\carnot\src\libraries 
. Now the simplepipe.c can be compiled by the command <br>mex simplepipe.c c:\carnot\src\libraries\carlib.c 
-Ic:\carnot\src\libraries <br><br>The S-function calculates a simple (straight) 
pipe, which is divided into a given number of nodes. <br>Heat transfer to the environment, 
Q&#x0307;<sub>amb</sub> = UA &middot; (T<sub>amb</sub> - T<sub>node</sub>), and<br>
due to convection, Q&#x0307;<sub>conv</sub> = &#x1E41; &middot; c<sub>P</sub> &middot; 
(T<sub>previous node</sub> - T<sub>node</sub>) are considered. The thermal mass 
of the pipe wall and heat flow due to conduction within the fluid are neglected. 
The basic differential equation is m<sub>node</sub> &middot; c<sub>P</sub> &middot; 
dT/dt = Q&#x0307;<sub>conv</sub> + Q&#x0307;<sub>amb</sub>. <br>As outputs, the 
outlet temperature, the node temperatures and the heat flows to the environment 
of each node are reported.<br>Parameters are the number of nodes, the fluid volume, 
the UA value and the initial temperature of each node.<br>As input the ambient temperature 
and data from the THB (fluid type, fluid mix, mass flow rate, pressure and temperature) 
are needed. <br><br>The basic work to is to include the carlib.h in your S-function. 
If you open the file carlib.h you will find the prototypes of the available function 
in carlib.c. In the example the function heat_capacity and density are used to calculate 
the specific heat capacity and density of the fluid. There are several other properties 
for different fluids included in the Carlib.<br>Most property function need the 
fluid type, the fluid mix, the temperature and the pressure as input. <br><br>To 
support developers there are enumerations available in carlib.h as well as in Simulink. 
For example, FluidEnum in Simulink has the same elements as the enum FLUID in carlib.c.</p>
<p></p>
<p><a name="creating_s_functions">The boiler model as an example</a></p>
<p>In the following section, the method used to get from the differential equation 
to the S-function implementation is described using the
<a href="#examples">examples</a> 
of the boiler model in the <a href="#carnot">CARNOT Library</a>. 
The boiler model is a simple model, which considers the heat transfer only for a 
constant nominal power, on the side of the furnace combustion chamber. A multinode 
model is used to model the time dependent conditions on the water side . The differential 
equation for the water temperature characteristic in the boiler is 
</p>
<p>
<img align="left" border="0" src="Formulas/formel_furnace_a.jpg"><br clear="all">
with the variables 
<table border="0">
	<tr>
		<th align="left">
		<p><u>symbol</u></p>
		</th>
		<th align="left">
		<p><u>used for</u></p>
		</th>
		<th align="left">
		<p><u>unit</u></p>
		</th>
	</tr>
	<tr>
		<td>
		<p>m</p>
		</td>
		<td>
		<p>actual mass at node</p>
		</td>
		<td>
		<p>[kg]</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>c</p>
		</td>
		<td>
		<p>heat capacity of fluid</p>
		</td>
		<td>
		<p>[J/(kg*K)]</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>T</p>
		</td>
		<td>
		<p>temperature of boiler water</p>
		</td>
		<td>
		<p>[K]</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>t</p>
		</td>
		<td>
		<p>time</p>
		</td>
		<td>
		<p>[s]</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>U<sub>1</sub></p>
		</td>
		<td>
		<p>heat loss coefficient to environment</p>
		</td>
		<td>
		<p>[W/m<sup>2</sup>K]</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Tamb</p>
		</td>
		<td>
		<p>ambient temperature</p>
		</td>
		<td>
		<p>[&deg;C]</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Tnode</p>
		</td>
		<td>
		<p>node temperature</p>
		</td>
		<td>
		<p>[&deg;C]</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>m<sub>dot</sub></p>
		</td>
		<td>
		<p>mass flow rate</p>
		</td>
		<td>
		<p>[kg/s]</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>P</p>
		</td>
		<td>
		<p>nominal power of the furnace</p>
		</td>
		<td>
		<p>[W]</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>N</p>
		</td>
		<td>
		<p>number of nodes</p>
		</td>
		<td>
		<p>[-]</p>
		</td>
	</tr>
</table>
</p>
<p>To insert the differential equation into the template 
S-function you have to transfer it to the form that only the differential term dT/dt 
is on the left side and all the other terms are on the right hand side of the equation.
<br class="auto-style3">The derivative term of 
the state variable is edited in the S-function with the symbol dx, so that the equation 
has to be added in the form </p>
<p><img border="0" class="auto-style1" src="Formulas/formel_furnace_b.jpg">
<br class="auto-style1" clear="all"></p>
<p>This would be the differential equation for one node, 
but as the model is a multinode one, you have to calculate the derivative at every 
node, so the calculation is carried out in a loop for every node. For the first 
node, Tlastnode is the input temperature, for all other nodes, it is the temperature 
of the preceding node. Therefore, the adaptation of tenter has to be performed within 
the loop, so the full loop must be: </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>for (n = 0; n &lt; nodes; n++)</tt> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>{</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>dx[n]=((Tamb-Tnode)*U1 
+ m<sub>dot</sub>*c*(Tenter-Tnode)+Pnom/nodes)/mnode/cp;</tt>
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>Tenter 
= Tnode;</tt> <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>}</tt>
</p>
<p>The above equation is the appropriate form of the differential 
equation for the multinode model in the S-function and has to be enter in the function 
block mdlDerivatives (...) in the S-function template file. </p>

<h2><a name="3.2_The_Carlib_Library">3.2 The Carlib Library</a></h2>
<h3>3.2.1 Using the Carlib functions in C-code</h3>
<p>The Carlib Library is built-up of functions that are 
included in the CARNOT subdirectory &quot;library_c\carlib&quot;. It contains the 
source code and corresponding header files of useful functions when creating your 
own C-MEX-files.</p>
<p>You can compile your s-function and include the 
carlib libarary "by hand":<br>
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mex file.c carlib.c</tt><br>
where &quot;file.c&quot; is the source code of the S-function to be compiled.</p>
<p>You may also take benefit of the build scripts included in Carnot (see MakeMEX.m).</p>
<p>To use the functions of the &quot;carlib&quot;, your 
source code file has to include the Carlib Library by specifing the command
<tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #include &quot;carlib.h&quot;</tt><br>
the header file that contains the prototype function declarations of the Carlib 
Library, for parameter type checking of the imported C-code. <br>
You may use the following CARNOT-Library functions, that are actually included 
in the Carlib source code file: </p>
<ul type="disc">
	<li>density</li>
	<li>density_solid </li>
	<li>enthalpy </li>
	<li>entropy </li>
	<li>evaporation_enthalpy </li>
	<li>enthalpy2temperature </li>
	<li>extraterrestrial_radiation </li>
	<li>grashof </li>
	<li>heat_capacity </li>
	<li>heat_capacity_solid </li>
	<li>mixViscosity </li>
	<li>thermal_conductivity </li>
	<li>temperature_conductivity </li>
	<li>prandtl </li>
	<li>prmessage </li>
	<li>rangecheck </li>
	<li>relativeHumidity2waterContent </li>
	<li>reynolds </li>
	<li>saturationproperty </li>
	<li>saturationtemperature </li>
	<li>square </li>
	<li>specific_volume </li>
	<li>saturationproperty </li>
	<li>solve_quadratic_equation</li>
	<li>solar_declination </li>
	<li>solar_time </li>
	<li>thermal_conductivity_solid </li>
	<li>unitconv_temp </li>
	<li>vapourcontent </li>
	<li>vapourpressure </li>
	<li>viscosity </li>
	<li>waterContent2relativeHumidity </li>
</ul>
<p>If you want to extend or change the <a href="#carlib_library">Carlib Library</a>, 
e.g. to add a new function to the server DLL (here carlib.dll) see chapter
<a href="#adding_functions_to_carlib">3.8 Adding Functions to the Carlib</a><br><br></p>

<h3><a name="fluidprop">3<strong>.2.1 Command-Window and Matlab function interface 
to Carlib : fluidprop</strong></a>
</h3>
<p>To use the files of the Carlib Library directly from 
the MATLAB command window or a Matlab function (.m, .mlx files), an Interface C-MEX-file <tt>
&quot;fluidprop.c&quot;</tt> 
was build, which is called from m.file lying in the Carnot main directory. As the 
m-file are named the same way as the respective fluid property you can directly 
type the name of the desired value to the MATLAB command window at the desired flow 
conditions. For example to resolve the value of the density, you can type to the 
workspace </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>density(&lt;temperature&gt;,&lt;pressure&gt;,fluid_type,fluidmix)</tt>
</p>
<p>as you would directly call the Carlib function.
</p>
<p>This call evoke the m-file density.m in the carnot 
main directory, where the functioncall </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>fluidprop(&lt;temp&gt;,&lt;pres&gt;,&lt;fluid_type&gt;,&lt;fluidmix&gt;,&lt;propertytype&gt;)</tt>
</p>
<p>is effectuated. If you call fluidprop with a negative 
property type the saurationvalues of the respective property is returned in vectorial 
form. </p>
<p>More information about the fluidtype, the fluidmix 
and the propertytype can be read in the paragraph of the THB vector definition.</p>
<p>The function fluidprop is a C-MEX (Matlab
EXecutable) that 
can be call directly from the workspace. If you specify a negative fluid property 
type, the values of saturated and boiling fluid, i. e. the values at saturation 
are promted in vectorial form, first the value of saturated steam and then the value 
of boiling fluid. </p>
<p></p>

<h3>3.2.2 Matlab Function block in Simulink</h3>
<p>You may use Carlib functions with the fluidprop interface also in the 
Simulink block "Matlab Function". But you have to add the command</p>
<p class="auto-style7">coder.extrinsic('Funktionsname') </p>
<p>in the head of your function before calling the function. Otherwise an error 
occurs, for example when calling the function solar_angles : </p>
<p>
<img alt="" height="138" src="Figures/1_Error_Functioncall_without_coderextrinsic.PNG" width="670" /></p>
<p>Also the output variables have to be declared before using them as left-hand 
side arguments. The corresponding error message is :</p>
<p>
<img alt="" height="123" src="Figures/2_Error_Functioncall_withoutInitVariables.PNG" width="662" /></p>
<p>With all this done the function call works correctly.</p>
<p>
<img alt="" height="371" src="Figures/3_functiocall_working.PNG" width="604" /></p>
<p></p>


<h2><a name="3.3_Rapid_Accelerator_Mode">3.3 Rapid Accelerator Mode</a></h2>
<p>Simulink support code generation and compilation of simulation models. The more 
parts are compiled and consequently not interpreted, the faster the calculation 
becomes. <br>There are three different modes, which can be used with most Carnot 
blocks out of the box: normal, accelerator and rapid accelerator mode. <br>In normal 
mode C-code S-functions are pre-compiled and consequently very fast. In accelerator 
mode Simulink blocks will executed faster. In rapid accelerator mode additionally 
(embedded) Matlab functions will accelerated.</p>
<p><img alt="" height="205" src="Figures/ChooseMode.png" width="720"></p>
<p>Standard setting is the normal mode. Here most of the functionality is done by 
Matlab / Simulink. It has the highest compatibility to other Mathworks toolboxes 
and allows most debugging, but is the slowest mode. If only plain Simulink blocks 
are used, no compiler is needed. <br>The accelerator mode compiles the model partially. 
In theory, most functionality of Mathworks products should be usable. However, there 
are some restrictions in practise. For example, the &quot;Data Display in Simulation&quot; 
does not work properly. The advantage of this mode is the acceleration of the Simulink 
blocks. Since Simulink blocks often consist of standard blocks, the compilation 
runs automatically. So the accelerator mode is a quite easy method to accelerate 
simulations. <br>As the name indicates, the rapid accelerator mode is the fastest 
mode. In this mode, the model will be compiled completely and run as an .exe. In 
the Windows task manager a new process with the model's name will appear. Since 
the rapid accelerator mode is linked to code generation, there are several implications:
</p>
<ul>
	<li>All blocks used must support code generation. For example, interpreted Matlab 
	functions or algebraic loops are not supported.</li>
	<li>Several functionalities can not be used, in spite of the fact that the model 
	will compile and execute. For example, no messages can be printed on the Matlab 
	prompt. Data logging in the Matlab workspace (e.g. via To Workspace blocks) 
	is not supported.</li>
	<li>While in normal or accelerator mode S-functions are links as .mex-files 
	(which are actually DLLs), the C-code of S-functions will be completely re-compiled. 
	This implies that Simulink needs information about the source code (see below). 
	If own S-functions are used, it might be a good idea to check if the results 
	are identical in normal and rapid accelerator mode. If there is a bug in the 
	C-code, the behaviour might be completely different, because due to the re-compilation 
	the addresses in memory may change. For example, a pointer (array), which is 
	not used properly, may lead to another address in memory. So a different result 
	in two different modes may indicate a bug in a C-S-function.</li>
	<li>Other functionalities can be used, but are very complicated to implement. 
	For example Matlab S-functions for S-functions in ForEach-Subsystems need knowledge 
	of the Target Language Compiler (TLC).<br>Although the Legacy Code Tool and 
	the S-Function Builder support generating TLC-files, most Carnot S-function 
	are not supported by these tools.</li>
</ul>
<p>There are different possibilities to give Simulink information about the C-code. 
A very simple way is to enter the source files in the model's configuration parameters.</p>
<p><img alt="" height="924" src="Figures/CustomCode.png" width="1343"></p>
<p><br>Simulink shows a very strange behaviour concerning the information needed: 
All .c-library files must be entered here (in most Carnot simulations carlib.c only).Furthermore, 
at least one file of each directory, where .c source files are located, must be 
entered. Since all public .c files in Carnot are located in one directory, it is 
sufficient to enter &quot;carlib.c&quot;. If own S-functions and own libraries are 
used, the corresponding files must be entered here. <br>If only public Carnot files 
are used, no further information must be entered. In the directory of the binary 
.mex files, a file named rtwmakecfg.m can be found.This file provides all information 
to Simulink for compiling a model in rapid accelerator mode. If an internal version 
of Carnot in generation by the version manager, this file will be created for the 
internal C-code as well. It is important that this file is in the same directory 
as the .mex files and that this directory is in the Matlab path. <br>To put it in 
a nutshell, the rapid accelerator mode is a very powerful method to accelerate code. 
However, it should be considered, which functionality can be used from the beginning 
of modelling.</p>

<h2><a name="3.4_Further_acceleration_methods">3.4 Further acceleration methods</a></h2>
<p>There are several methods to accelerate models provided by the Simulink documentation.
Examples are zero-crossings, time constants and different solvers. Please refer to
<a href="https://de.mathworks.com/company/newsletters/articles/improving-simulation-performance-in-simulink.html#IdentifyingSimulationBottlenecks">https://de.mathworks.com/company/newsletters/articles/improving-simulation-performance-in-simulink.html#IdentifyingSimulationBottlenecks</a>.
</p>

<h2><a name="3.5_Messages_and_error_handling">3.5 Messages and error handling</a></h2>
<p>There is a message support in Carnot.<br>In carlib.h and MessageLevelEnum.m different 
levels of messages are defined:<table>
	<tr>
		<th>carlib.h</th>
		<th>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</th>
		<th>MessageLevelEnum.m</th>
	</tr>
	<tr>
		<td>enum MESSAGELEVEL</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>classdef MessageLevelEnum &lt; Simulink.IntEnumType</td>
	</tr>
	<tr>
		<td>{</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>enumeration</td>
	</tr>
	<tr>
		<td>&nbsp;&nbsp;MESSAGELEVELDEBUG = 1,</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;DEBUGLEVEL(1)</td>
	</tr>
	<tr>
		<td>&nbsp;&nbsp;MESSAGELEVELINFO,</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;INFOLEVEL(2)</td>
	</tr>
	<tr>
		<td>&nbsp;&nbsp;MESSAGELEVELWARNING,</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;WARNINGLEVEL(3)</td>
	</tr>
	<tr>
		<td>&nbsp;&nbsp;MESSAGELEVELERROR,</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;ERRORLEVEL(4)</td>
	</tr>
	<tr>
		<td>&nbsp;&nbsp;MESSAGELEVELFATAL,</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;FATALLEVEL(5)</td>
	</tr>
	<tr>
		<td>&nbsp;&nbsp;MESSAGELEVELNONE</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;NOLEVEL(6)</td>
	</tr>
	<tr>
		<td>}</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>end</td>
	</tr>
	<tr>
		<td></td>
		<td></td>
		<td>end</td>
	</tr>
</table>
</p>
<p>There are five settings of a block or a model concerning the message (or debug) 
management:</p>
<ol>
	<li>Level The idea is that different information have different importance. 
	For a developer it might be very interesting to get some debug information, 
	whereas a normal user is not interested in this. So a block must be told, which 
	kind of information it should return. If for instance, the message level is 
	set to warning, all information with the priority warning, error and fatal should 
	be printed, whereas debug and info messages are suppressed. </li>
	<li>Maximum number of total messages It is possible to limit the maximum number 
	of printed messages. </li>
	<li>Maximum number of consecutive messages This option limits the number of 
	consecutive messages. If, for example, a problem causes messages in the following 
	time steps, only the first message could be interesting. So the amount of useless 
	messages can be reduced. </li>
	<li>Write messages to file If there are many messages, it might be interesting 
	to save the messages to a file. </li>
	<li>Name of the messages file </li>
</ol>
<p><strong>Example SimplePipeMessagesMDL</strong></p>
<p>Please open the model SimplePipeMessagesMDL. <br>There are three different positions 
in this model, where the message management is lined to: </p>
<ol>
	<li>Load callback The load callback can be found in the block's properties (right 
	click on the block, properties). It is run once a model is loaded into memory. 
	In this callback a function from the file CarnotCallbacks_SimplePipeMessages.m 
	is called. </li>
	<li>Mask initialisation callback In addition to the checks of the parameters, 
	one function of the file CarnotCallbacks_SimplePipeMessages.m are called.
	</li>
	<li>Mask parameter callback In the first parameter a callback is used, which 
	checks the visibility of the debug parameters. </li>
	<li>S-Function simplepipe_messages.c In the S-function the messages are set.
	</li>
</ol>
<p></p>
<p><img alt="" height="621" src="Figures/BlockProperties.png" width="502"></p>
<p><img alt="" height="647" src="Figures/BlockMask.png" width="1287"></p>
<p><strong>File CarnotCallbacks_SimplePipeMessages.m</strong></p>
<p>The code in the .m-file is documented, so only a brief overview is given here.
<br>This first function of the .m file consists of a wrapper. It calls the other 
functions in this file depending on the first input argument. The advantage of this 
approach is that only one file for all functions is needed. <br>The function LoadFcn 
is called in the Load Callback of the block. I reads the Enum MessageLevelEnum. 
Each possible element of this Enum is copied as text in the fifth parameter of the 
mask. This parameter is a popup menu, where the debug level of the block can be 
chosen. Since this function is called every time, the block is loaded, a change 
in the MessageLevelEnum will automatically change the popup menu of the block. It 
is not necessary to change the mask manually. <br>The function CheckDebugLevels 
is called by the mask init callback. It checks if in the model the parameters</p>
<ul>
	<li>DEBUGGLOBALLEVEL,</li>
	<li>DEBUGMAXTOTALWARNINGS,</li>
	<li>DEBUGMAXCONSECUTIVEWARNINGS,</li>
	<li>DEBUGWRITETOFILE,</li>
	<li>DEBUGFILENAME and</li>
	<li>DEBUGGLOBALLEVEL</li>
</ul>
<p>are present. These model parameters are set by the block GlobalMessageLevel. 
If they are set, the local entered parameters about the messages are overwritten.
</p>
<p>The function MaskVisibilities checks as the function CheckDebugGlobalLevels the 
existence of the global message model parameters. If they are present, the visibility 
of the block's message parameters is suppressed. </p>
<p><strong>File simplepipe_messages.c</strong></p>
<p>This file is an extension of simplepipe.c, because message management is used 
by this S-function: </p>
<ol>
	<li>There are five more parameters, which are the five above mentioned settings 
	level, maximum number of total messages, maximum number of consecutive messages, 
	write messages to file and filename. The corresponding defines are in lines 
	100-105 and the number of parameters in line 106 is 9 now. </li>
	<li>Four additional DWork vectors are included. These DWork vectors are introduced 
	in lines 120-123 as defines and in mdlInitializeSizes in lines 241-257. These 
	vectors consist of the name of the logging file "DWORK_FILENAME", the block's 
	(and S-function's) name "DWORK_ORIGIN", the total number of printed messages 
	"DWORK_TOTAL" and the number of consecutive printed messages "DWORK_CON". The 
	first two DWork vectors are UINT_8 type arrays. They actually consist characters. 
	Since characters are 8 bit variables, the same memory amount is used. The latter 
	two DWork vectors are of type uint32. </li>
	<li>In mdlInitialiszeSizes in lines 304-307, the new four DWork vectors are 
	initialised. The filename from the parameter is copies to the DWork vector called 
	"DWORK_FILENAME". The DWork Vector "DWORK_ORIGIN" will contain the block's name 
	and the name of the S-function. These information is returned by the Simulink 
	access functions ssGetPath(S) and ssGetModelName(S). By the function sprintf, 
	these information is copies to the DWork vector. The counters for the total 
	"DWORK_TOTAL" and consecutive "DWORK_CON" messages are set to 0. </li>
	<li>In mdlDerivatives the message management is used finally. In line 365 a 
	variable "messageset" is initialised with the enum "MESSAGEPRINTNONE". This 
	is important later on. The if statements in lines 375 and 381 check if the input 
	parameters for the Carlib functions heat_capacity() and density() are valid. 
	There is a function called rangecheck() in carlib.c defined (see below), which 
	returns "RANGEISCORRECT" if the range is valid or another value if not. Please 
	refer to the enum definition of "RANGECHECKERRORS" in carlib.h. Depending on 
	the procedure, this function return more information about the violation of 
	the validity range. However, in this example it is checked, if the inputs are 
	valid or not without considering further details. If the range is not valid 
	a corresponding message is prepared and send to the Carlib function printmessage(). 
	The input parameters of printmessage() are
	<ol>
		<li>the message (const char *)</li>
		<li>the block's name, which is the DWORK_ORIGIN DWork-Vector (const char *)</li>
		<li>the time stamp, which is returned by the Simulink function ssGetT(S) (double)</li>
		<li>the level of this message (here warning) (int)</li>
		<li>the level of the block, which is passed to the S-function as parameter (double)</li>
		<li>the already printed total messages, which is the DWork-Vector DWORK_TOTAL 
		(unsigned int*)</li>
		<li>the maximum number of total messages, which is passed to the S-function 
		as parameter (double)</li>
		<li>the number of consecutively printed messages, which is the DWork-Vector 
		DWORK_CON (unsigned int*)</li>
		<li>the number of maximum consecutively printed messages, which is passed 
		to the S-function as parameter (int)</li>
		<li>a variable, which tells weather the message shall be written to a file, 
		which is passed to the S-function as parameter (int)</li>
		<li>the name of the logging file, which is the DWork-Vector "DWORK_FILENAME" 
		(const char *)</li>
	</ol>
	Double type variable are used for the maximum number of total and consecutive 
	messages, which are passed to the S-function via parameters, instead of integer 
	values, because integer values do not support "inf" as value. <br>The function 
	return a enumerated value if the message was printed or not. </li>
	<li>The return value of the function printmessage() is needed in lines in the 
	if statement in line 409. If the return value is "MESSAGEPRINTNONE" or the function 
	has not been called (remember that initial value of "messageset" is "MESSAGEPRINTNONE", 
	the number of printed consecutive messages is set to zero. </li>
</ol>
<p><b>Please consider, that printing on the Matlab prompt from S-functions is not 
supported in rapid accelerator mode! Please use a logfile if you run the model in 
rapid accelerator mode.</b> </p>
<br>
<p>Range Check for the Properties in Carlib</p>
<p>The central function rangecheck() in Carlib allows to check if the input arguments 
for the material property functions are valid. The function rangecheck() has the 
inputs </p>
<ol>
	<li>property, that will be checked (int), see enum "PROPERTY"</li>
	<li>fluid id (double)</li>
	<li>fluid mix (double)</li>
	<li>temperature (double)</li>
	<li>pressure (double)</li>
</ol>
<p>The function returns an integer (int). According to the definition of the enum 
"RANGECHECKERRORS", the range is valid if the return value is "RANGEISCORRECT", 
which is zero. Since all violations of the range are connected by a binary or ("|") 
operator, all violations can be analysed individually. </p>

<h2><a name="3.6_Floating_point_accuracy">3.6 Floating point accuracy</a></h2>
<p>In computer memory variables are represented by a sequence of bits, i.e. of zeros 
and ones. Depending on the number of bits, more or less information can be stored. 
It is quite obvious that it is impossible to represent every possible floating number 
by a finite number of bits. Consequently, we face a maximum accuracy in floating 
point operations. In Windows, a variable of type double is represented by 64 bits. 
Consequently, there are 2<sup>64</sup>(about 1.89 &middot; 10<sup>19</sup>) different 
values possible. Checking the commands <i>realmax</i> and <i>realmin</i> in Matlab 
or the macros <i>DBL_MAX</i> (or <i>LDLB_MAX</i>) and <i>DBL_MIN</i> (or <i>LDBL_MIN</i>) 
defined in float.h in C we find that double type variables can represent the range 
between approximately -10<sup>308</sup> to 10<sup>308</sup>. The maximum accuracy 
of floating point variables can be found by the eps command in Matlab or the macros
<i>DLB_EPSILON</i> (or <i>LDB_EPSILON</i>) in C. <br>
<br>
Example (from
<a href="http://uk.mathworks.com/help/matlab/matlab_prog/floating-point-numbers.html#bqxyrhp">
http://uk.mathworks.com/help/matlab/matlab_prog/floating-point-numbers.html#bqxyrhp</a>):
<br>
<i>a = 0.0;</i> <br>
<i>for i = 1:10</i> <br>
<i>&nbsp;&nbsp;a = a + 0.1;</i> <br>
<i>end</i> <br>
<i>a == 1</i> <br>
<br>
The answer will be 0 (false). This might be considered to be strange, since a is 
really 1.0000 if you check it in Matlab, but here we face the maximum accuracy of 
floating point variables. <br>
So, how can we check if the variable <i>a</i> equals 1? We have to incorporate the 
accuracy of double type variables. We check if the variable <i>a</i> deviates from 
1 by a small number, e.g. <br>
<i>abs(a-1)&lt;1e-10</i> <br>
or <br>
<i>abs(a-1)&lt;eps(1)</i> <br>
will both return 1 (true). <br>
In carlib.h <i>NO_MASSFLOW</i> is defined to compare mass flow rates to zero. It 
is recommended to use this value. <br>
Since the pressure drop is represented by a quadratic equation in Carnot, it is 
often necessary to solve quadratic equations. In carlib.c a function called <i>solve_quadratic_equation</i> 
is implemented to do this. </p>
<p>This function expects four input arguments:</p>
<ol>
	<li>a pointer of type double to the two solutions of the quadratic equation. 
	It is important that the memory for the two data points has already been allocated.</li>
	<li>a double variable for the coefficient of the quadratic term</li>
	<li>a double variable for the coefficient of the linear term</li>
	<li>a double variable for the coefficient of the constant term</li>
</ol>
<p>For further reading please refer to <br>
<a href="http://uk.mathworks.com/help/matlab/matlab_prog/floating-point-numbers.html#bqxyrhp">
http://uk.mathworks.com/help/matlab/matlab_prog/floating-point-numbers.html#bqxyrhp</a>
<br>
<a href="http://en.wikipedia.org/wiki/Loss_of_significance">http://en.wikipedia.org/wiki/Loss_of_significance</a>
<br>
<a href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html</a>
<br>
<a href="http://stackoverflow.com/questions/10011544/solve-in-matlab-a-quadratic-equation-with-very-small-coefficients">
http://stackoverflow.com/questions/10011544/solve-in-matlab-a-quadratic-equation-with-very-small-coefficients</a>
</p>
<h2><a name="3.7_Target_Language_Compiler_(TLC)">3.7 Target Language Compiler (TLC)</a></h2>
<p>The Target Language Compiler can be used to manipulate generated code. This is 
interesting in embedded systems, but can be used in accelerator and rapid accelerator 
mode as well. For the latter modes an S-function needs a .tlc file. For example, 
this file will automatically be generated by the S-function builder of Simulink. 
If this .tlc file shall be used in accelerator mode, this has to be activated in 
the mdlInitializeSizes function of the S-function by <br>ssSetOptions(S, SS_OPTION_USE_TLC_WITH_ACCELERATOR)
<br>In Carnot this option should be activated in carlib.h for all files by uncommenting 
the line <br><br>&#160;&#160;&#160;#define CARNOT_USES_TLC_WITH_ACCELERATOR <br>
<br>In the .c source files this preprocessor definition is evaluated. One example 
is pump.c <br><br>#ifdef CARNOT_USES_TLC_WITH_ACCELERATOR<br>&#160;&#160;&#160;ssSetOptions(S,<br>&#160;&#160;&#160;&#160;&#160;SS_OPTION_WORKS_WITH_CODE_REUSE 
|<br>&#160;&#160;&#160;&#160;&#160;SS_OPTION_EXCEPTION_FREE_CODE |<br>&#160;&#160;&#160;&#160;&#160;SS_OPTION_USE_TLC_WITH_ACCELERATOR);<br>
#else<br>&#160;&#160;&#160;ssSetOptions(S,<br>&#160;&#160;&#160;&#160;&#160;SS_OPTION_WORKS_WITH_CODE_REUSE 
|<br>&#160;&#160;&#160;&#160;&#160;SS_OPTION_EXCEPTION_FREE_CODE);<br>#endif<br>
<br>For normal use, this option should not be activated. </p>
<h2><a name="3.8_Version_Management">3.8 Version Management</a></h2>
<p>The version manager is in the directory "version_manager" in the Carnot root 
directory. It can be used to build the Carnot library. This includes the public 
version as well as the internal version.
<br> In order to develop Carnot, it is splitted into so called atomic libraries, which later become the
blocks in the carnot library carnot.slx.
So a developer can change one block without disturbing other developers working
on other blocks. As a consequence all atomic libraries must be assembled to the Carnot
library release in the end. This is done by the functions of the version manager.
</p>
<p>In order to compile the .c-files, use the commands MakeMEX or 
MakeMEX_development, respectively. Both commands compile the .c-files from the 
directories src, library_simulink, library_c and library_m. However, MakeMEX 
will move all .c-files to the directory src whereas MakeMEX_development will 
copy the files only.
<br>Both files will create the rtwmakecfg.m. This file is used amongst others for the rapid accelerator mode.
Is can be found in the directory of the .mex-files and tells Simulink where to look for the source files and
the corresponding libraries.
<br>In order to build carnot.slx, use the command CreateCarnotMDL. It will look for all atomic libraries
in the public and internal directory and assembles them to file carnot.slx.
<br>Afterwards use the function CopyRemainingFiles. This will copy e.g. .m-files (e.g. callbacks) and help files
to the corresponding Carnot-directories.
<br>The script CleanUp will delete non-used files. For example, the single atomic libraries will not be
needed any more, because they can be found in the file carnot.slx.
<br>
</p>
<h2><a name="3.9_Extending_the_CARNOT_library_in_SIMULINK_environment">3.9 Extending the CARNOT 
library in SIMULINK environment</a> </h2>
<p>Creating a new model block for the 
<a href="#carnot">CARNOT Library</a> 
in the graphical environment of SIMULINK has many of the features used in creating 
a SIMULINK model. You can drag and drop other blocks from the CARNOT library or 
the basic blocks from the SIMULINK Library, that are to be used in your new block.
</p>
<p>In creating your model, the connections between the 
blocks that you use in your subsystem are affected by the Thermo-Hydraulic-Bus. 
It is recommended to use the &quot;Bus Assignment&quot; block to set the new values 
in the bus.&nbsp; </p>
<p>As you do not necessarily need all of these components, 
you can use a &quot;Bus Selector&quot; block to choose the vector into the components 
that you need in your model. Examples of ways of splitting the vector can be seen 
in many blocks and is shown for the block &quot;radiator&quot; in figure 3.2
</p>
<p><img alt="" src="Figures/chapt3_fig32_THBsplit.gif"><a name="figure_3_2"><br class="auto-style1" clear="all">
Fig. 3.2: Splitting and Assembly of the THB in the Block &quot;Electric 
Heater&quot; </a></p>
<p>After creating a new block for the 
<a href="#carnot">CARNOT Library</a>, 
you first have to verify it and make the 
process available for other users. It is recommended to use the 
<a href="../carnot/Validation/Template_Validation_Report.doc">
Verification template</a>s.
<br>Then you have to write the html help file. Remember that a new model is only 
helpfull with a good verification and documentation.<br></p>
<h2><a name="3.10_Adding_functions_and_fluids_to_the_Carlib">3.10 Adding functions and fluids to the 
Carlib</a></h2>
<p>Standard functions as for example entropie, vaporpressure 
or solartime and fluids are defined in the carlib.c file. These can be changed or 
new ones can be added. </p>
<ol>
	<li>add the function definition to the source file 
	(carlib.c) </li>
	<li>add the corresponding prototype declaration to 
	the header- file (carlib.h). This has to be done to enable parameter type checking 
	for the importing C-code (client.c). </li>
	<li>add the public function name to the export region 
	of the link-response-file, being created later from the batch file makecarlib.bat.
	</li>
</ol>
<p>If the functions or fluid is added and defined, the 
compiler has to create new mex files. </p>
<p>This can be done by calling the script 
</p>
<p><tt>MakeMEX.m</tt></p>
<p>or</p>
<p><tt>MakeMEX_development.m</tt>
</p>
<p><strong>ATTENTION</strong>: 
Be carefull to use MakeMEX. It creates a new Carnot library and delete some 
of your development files. Use MakeMEX_development if you are not sure.</p>
<p></p>

</body>

</html>
